import { dirname, isAbsolute, relative, resolve } from 'path'
import { promises as fs } from 'fs'
import { slash, throttle, toArray } from '@antfu/utils'
import { createFilter } from '@rollup/pluginutils'
import { isPackageExists } from 'local-pkg'
import type { Import } from 'unimport'
// @ts-expect-error types
import { vueTemplateAddon } from 'unimport/addons'
import { createUnimport, scanDirExports } from 'unimport'
import MagicString from 'magic-string'
import type { PresetName } from '../presets'
import { presets } from '../presets'
import type { ESLintrc, ImportExtended, ImportsMap, ImportsMapContent, Options } from '../types'

import { parseImport } from '../utils'
import { generateESLintConfigs } from './eslintrc'
import { resolversAddon } from './resolvers'

export function createContext(options: Options = {}, root = process.cwd()) {
  const imports = flattenImports(options.imports, options.presetOverriding)

  options.ignore?.forEach((name) => {
    const i = imports.find(i => i.as === name)
    if (i)
      i.disabled = true
  })

  const {
    dts: preferDTS = isPackageExists('typescript'),
  } = options

  const dirs = options.dirs?.map(dir => resolve(root, dir))

  const eslintrc: ESLintrc = options.eslintrc || {}
  eslintrc.enabled = eslintrc.enabled === undefined ? false : eslintrc.enabled
  eslintrc.filepath = eslintrc.filepath || './.eslintrc-auto-import.json'
  eslintrc.globalsPropValue = eslintrc.globalsPropValue === undefined ? true : eslintrc.globalsPropValue

  const resolvers = options.resolvers ? [options.resolvers].flat(2) : []

  const unimport = createUnimport({
    imports: imports as Import[],
    presets: [],
    addons: [
      ...(options.vueTemplate ? [vueTemplateAddon()] : []),
      resolversAddon(resolvers),
      {
        declaration(dts) {
          if (!dts.endsWith('\n'))
            dts += '\n'
          return `// Generated by 'unplugin-auto-import'\n${dts}`
        },
      },
    ],
  })

  const filter = createFilter(
    options.include || [/\.[jt]sx?$/, /\.vue$/, /\.vue\?vue/, /\.svelte$/],
    options.exclude || [/[\\/]node_modules[\\/]/, /[\\/]\.git[\\/]/],
  )
  const dts = preferDTS === false
    ? false
    : preferDTS === true
      ? resolve(root, 'auto-imports.d.ts')
      : resolve(root, preferDTS)

  function generateDTS(file: string) {
    const dir = dirname(file)
    return unimport.generateTypeDeclarations({
      resolvePath: (i) => {
        if (i.from.startsWith('.') || isAbsolute(i.from)) {
          const related = slash(relative(dir, i.from).replace(/\.ts$/, ''))
          return !related.startsWith('.')
            ? `./${related}`
            : related
        }
        return i.from
      },
    })
  }

  function generateESLint() {
    return generateESLintConfigs(unimport.getImports(), eslintrc)
  }

  const writeConfigFilesThrottled = throttle(500, false, writeConfigFiles)

  let lastDTS: string | undefined
  let lastESLint: string | undefined
  function writeConfigFiles() {
    const promises: any[] = []
    if (dts) {
      const content = generateDTS(dts)
      if (content !== lastDTS) {
        lastDTS = content
        promises.push(fs.writeFile(dts, content, 'utf-8'))
      }
    }
    if (eslintrc.enabled && eslintrc.filepath) {
      const content = generateESLint()
      if (content !== lastESLint) {
        lastESLint = content
        promises.push(fs.writeFile(eslintrc.filepath, content, 'utf-8'))
      }
    }
    return Promise.all(promises)
  }

  async function scanDirs() {
    if (dirs?.length) {
      await unimport.modifyDynamicImports(async (imports) => {
        const exports = await scanDirExports(dirs) as ImportExtended[]
        exports.forEach(i => i.__source = 'dir')
        return [
          ...imports.filter((i: ImportExtended) => i.__source !== 'dir'),
          ...exports,
        ] as Import[]
      })
    }
    writeConfigFilesThrottled()
  }

  async function transform(code: string, id: string) {
    const s = new MagicString(code)

    await unimport.injectImports(s, id)

    if (!s.hasChanged())
      return

    writeConfigFilesThrottled()

    return {
      code: s.toString(),
      map: s.generateMap({ source: id, includeContent: true }),
    }
  }

  if (!imports.length && !resolvers.length)
    console.warn('[auto-import] plugin installed but no imports has defined, see https://github.com/antfu/unplugin-auto-import#configurations for configurations')

  return {
    root,
    dirs,
    filter,
    scanDirs,
    writeConfigFiles,
    writeConfigFilesThrottled,
    transform,
    generateDTS,
    generateESLint,
  }
}

export function flattenImports(map: Options['imports'], overriding = false): Import[] {
  const flat: Record<string, Import> = {}
  let importDefinitions: ImportsMap = {}
  toArray(map).forEach((definition) => {
    importDefinitions = {}
    if (typeof definition === 'string') {
      if (!presets[definition])
        throw new Error(`[auto-import] preset ${definition} not found`)
      const preset = presets[definition]
      importDefinitions = typeof preset === 'function' ? preset() : preset
    }
    else {
      for (const presetName of Object.keys(definition)) {
        const { presetExclude, presetAlias } = parseImport(presetName, definition[presetName])
        // include only(just pass the object)
        if (presetExclude.length === 0) {
          importDefinitions[presetName] = definition[presetName]
        }
        else {
          if (!presets[presetName as PresetName])
            throw new Error(`[auto-import] exclude import could not be used on undifined preset ${presetName}`)
          const preset = presets[presetName as PresetName]
          const presetDefinition = typeof preset === 'function' ? preset() : preset
          const needImport: ImportsMapContent = []

          for (const definedImport of presetDefinition[Object.keys(presetDefinition)[0]]) {
            // currently preset don't have alias import
            if (typeof definedImport === 'string') {
              if (!presetExclude.includes(definedImport)) {
                if (Object.keys(presetAlias).includes(definedImport))
                  needImport.push(presetAlias[definedImport])

                else
                  needImport.push(definedImport)
              }
            }
          }
          importDefinitions[presetName] = needImport
        }
      }
    }

    for (const mod of Object.keys(importDefinitions)) {
      for (const id of importDefinitions[mod]) {
        const meta = {
          from: mod,
        } as Import
        let name: string
        if (Array.isArray(id)) {
          name = id[1]
          meta.name = id[0]
          meta.as = id[1]
        }
        else {
          name = id
          meta.name = id
          meta.as = id
        }

        if (flat[name] && !overriding)
          throw new Error(`[auto-import] identifier ${name} already defined with ${flat[name].from}`)

        flat[name] = meta
      }
    }
  })

  return Object.values(flat)
}
